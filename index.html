<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>授受簿サンプル（独立ヘッダ＋先頭列）レスポンシブ対応</title>
  <style>
    /* ======== 全体レイアウト ======== */
    html, body {
      margin: 0; 
      padding: 0;
      height: 100%;  /* 画面いっぱい使う */
    }
    body {
      display: flex;
      flex-direction: column;
      font-family: sans-serif;
    }

    /* 親コンテナ：上下に分割。上は操作パネル、下がメイン(ヘッダとテーブル群) */
    .container {
      display: flex;
      flex-direction: column;
      flex: 1;  /* 画面高さの余りを占有 */
    }

    /* ======== 操作パネル部分 ======== */
    .operator-section {
      flex: 0 0 auto;
      padding: 8px 16px;
      background: #f9f9f9;
      border-bottom: 1px solid #ccc;
    }

    /* ======== ヘッダテーブルのラッパ ======== */
    #headerContainer {
      /* 横スクロール同期用に overflow-x: auto; */
      overflow-x: auto;
      border-bottom: 1px solid #ccc;
      width: 100%; /* 横いっぱい使う */
    }

    /* ヘッダテーブル本体 */
    #headerTable {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
      white-space: nowrap; /* 折り返しせずに横スクロール */
    }
    #headerTable th {
      border: 1px solid #ccc;
      padding: 8px;
      background: #f0f0f0;
      text-align: center;
      cursor: pointer; /* ソート切り替え用 */
      min-width: 100px;
    }

    /* ======== メイン表示エリア ======== */
    .main-container {
      flex: 1; /* 残りの高さを全部使う */
      display: flex;
      overflow: hidden; /* 子コンテナでスクロールを管理 */
    }

    /* 左テーブル用コンテナ（付託番号） */
    #leftContainer {
      overflow-y: hidden; /* 縦スクロールは #rightContainer で行い同期 */
      border-right: 1px solid #ccc;
      flex: 0 0 auto;
      background: #fff;
    }
    #leftTable {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
      white-space: nowrap;
    }
    #leftTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
      vertical-align: middle;
      min-width: 80px; /* 付託番号欄の最低幅 */
    }

    /* 右テーブル用コンテナ（メイン項目） */
    #rightContainer {
      overflow: auto; /* ここで縦横スクロール */
      flex: 1;
      background: #fff;
    }
    #rightTable {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
      white-space: nowrap;
    }
    #rightTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
      vertical-align: middle;
      min-width: 100px; /* a,b,c,dグループ欄の最低幅 */
    }

    /* ======== 完了行のスタイル（表示/非表示はJS） ======== */
    .completed-left {
      background-color: #e0ffe0;
    }
    .completed-right {
      background-color: #e0ffe0;
    }

    /* ======== ボタンのスタイル ======== */
    .fill-operator-btn,
    .fill-date-btn {
      margin-left: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    /* ======== レスポンシブ対応（モバイル等で幅が狭いとき） ======== */
    @media (max-width: 768px) {
      .main-container {
        flex-direction: column; /* 左右分割→上下分割へ */
      }
      #leftContainer {
        flex: 0 0 auto;
        overflow-x: auto; /* 横スクロールを許可 */
        border: none;
        border-bottom: 1px solid #ccc;
      }
      #rightContainer {
        flex: 1;
        overflow: auto; /* 縦スクロール */
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- 操作パネル -->
    <div class="operator-section">
      <label>操作者名：
        <input type="text" id="operatorName" placeholder="操作者名を入力" />
      </label>
      <label style="margin-left:16px;">
        <input type="checkbox" id="showCompletedToggle" />
        完了項目を再表示
      </label>
    </div>

    <!-- ヘッダー独立テーブル -->
    <div id="headerContainer">
      <table id="headerTable">
        <thead>
          <tr>
            <th data-col="futakuNo">付託番号</th>
            <th data-col="a_name">a. 記載者名</th>
            <th data-col="a_date">a. 月日</th>
            <th data-col="b_name">b. 受け取り者名</th>
            <th data-col="b_date">b. 月日</th>
            <th data-col="c_name">c. 返却者名</th>
            <th data-col="c_date">c. 月日</th>
            <th data-col="d_name">d. 受け取り者名</th>
            <th data-col="d_date">d. 月日</th>
          </tr>
        </thead>
      </table>
    </div>

    <!-- メイン部： 左(付託番号テーブル) + 右(その他項目テーブル) -->
    <div class="main-container">
      <!-- 左：付託番号だけを並べるテーブル -->
      <div id="leftContainer">
        <table id="leftTable">
          <tbody>
            <!-- JSで行を追加 -->
          </tbody>
        </table>
      </div>

      <!-- 右：a,b,c,d などの項目を並べるテーブル -->
      <div id="rightContainer">
        <table id="rightTable">
          <tbody>
            <!-- JSで行を追加 -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    /********************************************************
     * グローバル変数や要素参照
     ********************************************************/
    const operatorNameInput = document.getElementById("operatorName");
    const showCompletedToggle = document.getElementById("showCompletedToggle");

    const headerContainer = document.getElementById("headerContainer");
    const leftContainer = document.getElementById("leftContainer");
    const rightContainer = document.getElementById("rightContainer");

    const leftTableBody = document.querySelector("#leftTable tbody");
    const rightTableBody = document.querySelector("#rightTable tbody");

    // 行ID -> { id, leftTr, rightTr, completed }
    let rowDataMap = {};
    // ソート関連
    let currentSortCol = null;
    let currentSortDir = 1; // 1: 昇順, -1: 降順

    /********************************************************
     * ページ読み込み後の初期化
     ********************************************************/
    window.addEventListener("DOMContentLoaded", () => {
      attachHeaderSortEvents();
      loadDataFromStorage();
      addNewRowIfNeeded();

      // スクロール同期
      rightContainer.addEventListener("scroll", syncScroll);
      // 完了項目を再表示
      showCompletedToggle.addEventListener("change", toggleCompletedVisibility);
    });

    /********************************************************
     * スクロール同期
     ********************************************************/
    function syncScroll() {
      // 縦スクロールを左コンテナに同期
      leftContainer.scrollTop = rightContainer.scrollTop;
      // 横スクロールをヘッダコンテナに同期
      headerContainer.scrollLeft = rightContainer.scrollLeft;
    }

    /********************************************************
     * 行追加
     ********************************************************/
    function addNewRow() {
      const newId = Date.now().toString();

      // 左側（付託番号）行
      const leftTr = document.createElement("tr");
      const futakuTd = document.createElement("td");
      const futakuInput = document.createElement("input");
      futakuInput.type = "text";
      futakuInput.name = "futakuNo";
      futakuTd.appendChild(futakuInput);
      leftTr.appendChild(futakuTd);
      leftTableBody.appendChild(leftTr);

      // 右側（a,b,c,dグループ）行
      const rightTr = document.createElement("tr");
      // a. 記載者名
      const aNameTd = createInputTd("a_name");
      rightTr.appendChild(aNameTd);
      // a. 月日
      const aDateTd = createDateTd("a_date");
      rightTr.appendChild(aDateTd);
      // b. 受け取り者名
      const bNameTd = createInputTd("b_name");
      rightTr.appendChild(bNameTd);
      // b. 月日
      const bDateTd = createDateTd("b_date");
      rightTr.appendChild(bDateTd);
      // c. 返却者名
      const cNameTd = createInputTd("c_name");
      rightTr.appendChild(cNameTd);
      // c. 月日
      const cDateTd = createDateTd("c_date");
      rightTr.appendChild(cDateTd);
      // d. 受け取り者名
      const dNameTd = createInputTd("d_name");
      rightTr.appendChild(dNameTd);
      // d. 月日
      const dDateTd = createDateTd("d_date");
      rightTr.appendChild(dDateTd);

      rightTableBody.appendChild(rightTr);

      // rowDataMapに登録
      rowDataMap[newId] = {
        id: newId,
        leftTr: leftTr,
        rightTr: rightTr,
        completed: false
      };

      // イベントリスナ登録
      futakuInput.addEventListener("change", () => checkAndSaveRow(newId));
      rightTr.querySelectorAll("input").forEach(input => {
        input.addEventListener("change", () => checkAndSaveRow(newId));
      });

      return newId;
    }

    // テキスト入力セルを生成
    function createInputTd(name) {
      const td = document.createElement("td");
      const input = document.createElement("input");
      input.type = "text";
      input.name = name;

      const btn = document.createElement("button");
      btn.className = "fill-operator-btn";
      btn.textContent = "操作者名";
      btn.onclick = () => {
        input.value = operatorNameInput.value;
        findAndCheckRowId(td);
      };

      td.appendChild(input);
      td.appendChild(btn);
      return td;
    }

    // 日付入力セルを生成
    function createDateTd(name) {
      const td = document.createElement("td");
      const input = document.createElement("input");
      input.type = "date";
      input.name = name;

      const btn = document.createElement("button");
      btn.className = "fill-date-btn";
      btn.textContent = "今日";
      btn.onclick = () => {
        input.value = getToday();
        findAndCheckRowId(td);
      };

      td.appendChild(input);
      td.appendChild(btn);
      return td;
    }

    // 親TRを遡って rowId を探す→ checkAndSaveRow() を呼び出す
    function findAndCheckRowId(td) {
      const tr = td.closest("tr");
      if (!tr) return;
      for (let k in rowDataMap) {
        if (rowDataMap[k].rightTr === tr) {
          checkAndSaveRow(k);
          break;
        }
      }
    }

    // 今日の日付(YYYY-MM-DD)
    function getToday() {
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth() + 1).padStart(2, '0');
      const d = String(now.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    /********************************************************
     * 最下行が入力済みなら新行を追加
     ********************************************************/
    function addNewRowIfNeeded() {
      const keys = Object.keys(rowDataMap);
      if (keys.length === 0) {
        addNewRow();
        return;
      }
      // 最新行IDを特定（数値ソートで最大IDを取得）
      const lastId = keys.map(k => parseInt(k,10)).sort((a,b)=>a-b).pop();
      const rowObj = rowDataMap[lastId];

      const futakuInput = rowObj.leftTr.querySelector("input[name='futakuNo']");
      const rightInputs = rowObj.rightTr.querySelectorAll("input");

      let filled = false;
      if (futakuInput.value.trim() !== "") filled = true;
      rightInputs.forEach(inp => {
        if (inp.value.trim() !== "") filled = true;
      });
      if (filled) {
        addNewRow();
      }
    }

    /********************************************************
     * 行の完了チェック＆保存
     ********************************************************/
    function checkAndSaveRow(rowId) {
      const rowObj = rowDataMap[rowId];
      if (!rowObj) return;

      const futakuVal = rowObj.leftTr.querySelector("input[name='futakuNo']").value.trim();
      const aNameVal = rowObj.rightTr.querySelector("input[name='a_name']").value.trim();
      const aDateVal = rowObj.rightTr.querySelector("input[name='a_date']").value.trim();
      const bNameVal = rowObj.rightTr.querySelector("input[name='b_name']").value.trim();
      const bDateVal = rowObj.rightTr.querySelector("input[name='b_date']").value.trim();
      const cNameVal = rowObj.rightTr.querySelector("input[name='c_name']").value.trim();
      const cDateVal = rowObj.rightTr.querySelector("input[name='c_date']").value.trim();
      const dNameVal = rowObj.rightTr.querySelector("input[name='d_name']").value.trim();
      const dDateVal = rowObj.rightTr.querySelector("input[name='d_date']").value.trim();

      // 全て埋まっていれば完了
      const isComplete = (futakuVal && aNameVal && aDateVal && bNameVal && bDateVal &&
                          cNameVal && cDateVal && dNameVal && dDateVal);

      rowObj.completed = isComplete;

      if (isComplete) {
        rowObj.leftTr.classList.add("completed-left");
        rowObj.rightTr.classList.add("completed-right");
        if (!showCompletedToggle.checked) {
          rowObj.leftTr.style.display = "none";
          rowObj.rightTr.style.display = "none";
        } else {
          rowObj.leftTr.style.display = "";
          rowObj.rightTr.style.display = "";
        }
      } else {
        rowObj.leftTr.classList.remove("completed-left");
        rowObj.rightTr.classList.remove("completed-right");
        rowObj.leftTr.style.display = "";
        rowObj.rightTr.style.display = "";
      }

      saveDataToStorage();
      addNewRowIfNeeded();
    }

    /********************************************************
     * 完了行の再表示・非表示の切り替え
     ********************************************************/
    function toggleCompletedVisibility() {
      const showComp = showCompletedToggle.checked;
      Object.values(rowDataMap).forEach(rowObj => {
        if (rowObj.completed) {
          rowObj.leftTr.style.display = showComp ? "" : "none";
          rowObj.rightTr.style.display = showComp ? "" : "none";
        }
      });
    }

    /********************************************************
     * ソート機能
     ********************************************************/
    function attachHeaderSortEvents() {
      const headerThs = document.querySelectorAll("#headerTable th");
      headerThs.forEach(th => {
        th.addEventListener("click", () => {
          const colName = th.dataset.col;
          if (colName === currentSortCol) {
            // 同じ列を再度クリックすると昇降反転
            currentSortDir *= -1;
          } else {
            currentSortCol = colName;
            currentSortDir = 1;
          }
          sortByColumn(colName);
        });
      });
    }

    function sortByColumn(colName) {
      // rowDataMap から rowObj配列を取り出し、
      // ソート後、左テーブルtbody, 右テーブルtbody の順序を並べ替える
      const rowObjs = Object.values(rowDataMap);

      rowObjs.sort((a, b) => {
        const valA = getRowValue(a, colName);
        const valB = getRowValue(b, colName);
        if (valA < valB) return -1 * currentSortDir;
        if (valA > valB) return 1 * currentSortDir;
        return 0;
      });

      // ソート後に append し直す
      rowObjs.forEach(rowObj => {
        leftTableBody.appendChild(rowObj.leftTr);
        rightTableBody.appendChild(rowObj.rightTr);
      });
    }

    // 指定した行の指定列の値
    function getRowValue(rowObj, colName) {
      if (colName === "futakuNo") {
        const inp = rowObj.leftTr.querySelector("input[name='futakuNo']");
        return inp ? inp.value : "";
      } else {
        const inp = rowObj.rightTr.querySelector(`input[name='${colName}']`);
        return inp ? inp.value : "";
      }
    }

    /********************************************************
     * データの保存・読み込み
     ********************************************************/
    function saveDataToStorage() {
      const storeObj = {};
      Object.keys(rowDataMap).forEach(rowId => {
        const rowObj = rowDataMap[rowId];
        const futakuVal = rowObj.leftTr.querySelector("input[name='futakuNo']").value;
        const aNameVal = rowObj.rightTr.querySelector("input[name='a_name']").value;
        const aDateVal = rowObj.rightTr.querySelector("input[name='a_date']").value;
        const bNameVal = rowObj.rightTr.querySelector("input[name='b_name']").value;
        const bDateVal = rowObj.rightTr.querySelector("input[name='b_date']").value;
        const cNameVal = rowObj.rightTr.querySelector("input[name='c_name']").value;
        const cDateVal = rowObj.rightTr.querySelector("input[name='c_date']").value;
        const dNameVal = rowObj.rightTr.querySelector("input[name='d_name']").value;
        const dDateVal = rowObj.rightTr.querySelector("input[name='d_date']").value;

        storeObj[rowId] = {
          completed: rowObj.completed,
          values: {
            futakuNo: futakuVal,
            a_name: aNameVal,
            a_date: aDateVal,
            b_name: bNameVal,
            b_date: bDateVal,
            c_name: cNameVal,
            c_date: cDateVal,
            d_name: dNameVal,
            d_date: dDateVal
          }
        };
      });
      localStorage.setItem("flowDataComplex", JSON.stringify(storeObj));
    }

    function loadDataFromStorage() {
      const str = localStorage.getItem("flowDataComplex");
      if (!str) return;
      const stored = JSON.parse(str);

      // 1行ずつ復元
      Object.keys(stored).forEach(rowId => {
        const rowInfo = stored[rowId];
        const newCreatedId = addNewRow();

        // addNewRow() で生成された臨時ID の rowObjを取得し、置き換える
        const newObj = rowDataMap[newCreatedId];
        delete rowDataMap[newCreatedId];

        rowDataMap[rowId] = newObj;
        newObj.id = rowId;

        // 左(付託番号)
        newObj.leftTr.querySelector("input[name='futakuNo']").value =
          rowInfo.values.futakuNo || "";

        // 右(a,b,c,d...)
        newObj.rightTr.querySelector("input[name='a_name']").value = rowInfo.values.a_name || "";
        newObj.rightTr.querySelector("input[name='a_date']").value = rowInfo.values.a_date || "";
        newObj.rightTr.querySelector("input[name='b_name']").value = rowInfo.values.b_name || "";
        newObj.rightTr.querySelector("input[name='b_date']").value = rowInfo.values.b_date || "";
        newObj.rightTr.querySelector("input[name='c_name']").value = rowInfo.values.c_name || "";
        newObj.rightTr.querySelector("input[name='c_date']").value = rowInfo.values.c_date || "";
        newObj.rightTr.querySelector("input[name='d_name']").value = rowInfo.values.d_name || "";
        newObj.rightTr.querySelector("input[name='d_date']").value = rowInfo.values.d_date || "";

        // 完了状態
        newObj.completed = rowInfo.completed;
        if (rowInfo.completed) {
          newObj.leftTr.classList.add("completed-left");
          newObj.rightTr.classList.add("completed-right");
          // 「完了項目を再表示」がOFFなら非表示
          if (!showCompletedToggle.checked) {
            newObj.leftTr.style.display = "none";
            newObj.rightTr.style.display = "none";
          }
        }
      });
    }
  </script>
</body>
</html>
